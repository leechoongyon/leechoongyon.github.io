<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://leechoongyon.github.io//jekyll-theme-yat/feed.xml" rel="self" type="application/atom+xml" /><link href="https://leechoongyon.github.io//jekyll-theme-yat/" rel="alternate" type="text/html" /><updated>2024-07-20T07:00:28+00:00</updated><id>https://leechoongyon.github.io//jekyll-theme-yat/feed.xml</id><title type="html">Simple is best</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>leechoongyon</name></author><entry><title type="html">Leetcode209.Minimum Size Subarray Sum</title><link href="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/04/15/Leetcode209.MinimumSizeSubarraySum.html" rel="alternate" type="text/html" title="Leetcode209.Minimum Size Subarray Sum" /><published>2024-04-15T00:00:00+00:00</published><updated>2024-04-15T00:00:00+00:00</updated><id>https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/04/15/Leetcode209.MinimumSizeSubarraySum</id><content type="html" xml:base="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/04/15/Leetcode209.MinimumSizeSubarraySum.html"><![CDATA[<blockquote>
  <p><a href="https://github.com/leechoongyon/coding-test-kotlin/blob/main/src/main/kotlin/org/example/leetcode/Num209.kt">소스코드</a></p>
</blockquote>

<h1 id="문제">문제</h1>

<ul>
  <li>
    <p><a href="https://leetcode.com/problems/minimum-size-subarray-sum/description/">209. Minimum Size Subarray Sum</a></p>
  </li>
  <li>양수 nums (int array), 양수 target 이 주어짐</li>
  <li>nums 부분배열의 합이 크거나 같은 subarray (연속적) min length 구하기</li>
</ul>

<h1 id="풀이-window">풀이 (window)</h1>

<ul>
  <li>window 생각하고 포인터를 이동시키면서 subarray length 구하면 됨</li>
  <li>자세한 설명은 아래 주석</li>
</ul>

<h1 id="source">source</h1>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	 <span class="cm">/**
     *  1. 문제
     *  - 양수 nums 주어짐
     *  - 양수 target 도 주어짐
     *  - 부분배열의 합이 크거나 같은 minimal length 였네.
     *  - 연속된 sequence 맞네
     *      - 여러개가 나올 수 있음. 최소 length 를 구해야함
     *  - 답이 없으면 0 을 return
     *  - 시간복잡도를 O(n) 이 아니라 O(nlog(n)) 으로 풀어야 함
     *
     *  Constraints:
     * 1 &lt;= target &lt;= 10 9승
     * 1 &lt;= nums.length &lt;= 10 5승
     * 1 &lt;= nums[i] &lt;= 10 4승
     *
     *
     *  2. 풀이
     *  2.1 window
     *  - start, end 동시에 0 부터 시작
     *  - 순회할 때는 end 를 늘리고, target 이 넘어가면 start 를 늘리는거였나
     *  - 음 잘못푼거 같은데 -&gt; 최소 length 를 구해야함
     *  - nums 순회하면서 시작점을 한칸씩 이동해서 window 를 구해야하나?
     *  - nums element 는 양수니까 window 가 target 넘어서는 순간 더 이상 구할 필요 없음
     *  - 시간복잡도 O(n 제곱)
     *  - 문제를 잘못이해했네. subarray (연속적인 sequence) target 보다 크거나 같은 것을 구하는 것
     *
     *  처음에는 for loop 2번 돌렸음
     *  개선해서 for loop 1번만 돌려도 됨
     *  target &lt;= sum 이면 start++ 하면서 pointer 이동
     */</span>

    <span class="k">fun</span> <span class="nf">minSubArrayLen2</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nc">Int</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="nc">IntArray</span><span class="p">):</span> <span class="nc">Int</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="py">minSubArrayLen</span> <span class="p">=</span> <span class="nc">Integer</span><span class="p">.</span><span class="nc">MAX_VALUE</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="py">sum</span> <span class="p">=</span> <span class="mi">0</span>
            <span class="kd">var</span> <span class="py">start</span> <span class="p">=</span> <span class="n">i</span>
            <span class="kd">var</span> <span class="py">end</span> <span class="p">=</span> <span class="n">i</span>

            <span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="p">&lt;=</span> <span class="n">end</span> <span class="p">&amp;&amp;</span> <span class="n">end</span> <span class="p">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sum</span> <span class="p">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="p">&gt;=</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">minSubArrayLen</span> <span class="p">=</span> <span class="nc">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="n">end</span> <span class="p">-</span> <span class="n">start</span> <span class="p">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">minSubArrayLen</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="p">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">end</span><span class="p">++</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">if</span> <span class="p">(</span><span class="n">minSubArrayLen</span> <span class="p">==</span> <span class="nc">Integer</span><span class="p">.</span><span class="nc">MAX_VALUE</span><span class="p">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">minSubArrayLen</span>
    <span class="p">}</span>

    <span class="k">fun</span> <span class="nf">minSubArrayLen</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nc">Int</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="nc">IntArray</span><span class="p">):</span> <span class="nc">Int</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="py">minSubArrayLen</span> <span class="p">=</span> <span class="nc">Integer</span><span class="p">.</span><span class="nc">MAX_VALUE</span>
        <span class="kd">var</span> <span class="py">sum</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="kd">var</span> <span class="py">start</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="kd">var</span> <span class="py">end</span> <span class="p">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="p">&lt;=</span> <span class="n">end</span> <span class="p">&amp;&amp;</span> <span class="n">end</span> <span class="p">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="p">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="p">&gt;=</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">minSubArrayLen</span> <span class="p">=</span> <span class="nc">Math</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="n">end</span> <span class="p">-</span> <span class="n">start</span> <span class="p">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">minSubArrayLen</span><span class="p">)</span>
                <span class="n">sum</span> <span class="p">-=</span> <span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
                <span class="n">sum</span> <span class="p">-=</span> <span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>
                <span class="n">start</span><span class="p">++</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="p">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">end</span><span class="p">++</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">if</span> <span class="p">(</span><span class="n">minSubArrayLen</span> <span class="p">==</span> <span class="nc">Integer</span><span class="p">.</span><span class="nc">MAX_VALUE</span><span class="p">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">minSubArrayLen</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name>leechoongyon</name></author><category term="leetcode" /><category term="leetcode" /><summary type="html"><![CDATA[소스코드]]></summary></entry><entry><title type="html">Leetcode167.RemoveDuplicatesFromSortedArrayII</title><link href="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/04/14/Leetcode167.html" rel="alternate" type="text/html" title="Leetcode167.RemoveDuplicatesFromSortedArrayII" /><published>2024-04-14T00:00:00+00:00</published><updated>2024-04-14T00:00:00+00:00</updated><id>https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/04/14/Leetcode167</id><content type="html" xml:base="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/04/14/Leetcode167.html"><![CDATA[<blockquote>
  <p><a href="https://github.com/leechoongyon/coding-test-kotlin/blob/main/src/main/kotlin/org/example/leetcode/Num167.kt">소스코드</a></p>
</blockquote>

<h1 id="문제">문제</h1>

<ul>
  <li><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/">167. Two Sum II - Input Array Is Sorted</a></li>
  <li>numbers int array 가 주어지며, numbers 중 2개의 숫자를 더해 target 을 만족</li>
</ul>

<h1 id="풀이-brute-force">풀이 (brute-force)</h1>

<ul>
  <li>
    <p>시간복잡도 O (n 제곱)</p>
  </li>
  <li>
    <p>for 2번 돌리면서 순회 target 보다 크면 stop</p>
  </li>
</ul>

<h1 id="풀이공간-사용">풀이(공간 사용)</h1>

<ul>
  <li>Map 에 저장을 한다</li>
  <li>for loop 순회하면서 target - numbers[i] = map 에 있는지 체크</li>
  <li>이러면 시간복잡도 O(n), 공간복잡도 또한 O(n)</li>
</ul>

<h1 id="풀이-two-pointer">풀이 (two Pointer)</h1>

<ul>
  <li>양끝에서 시작</li>
  <li>양끝의 합이 target 보다 크면 right–</li>
  <li>양끝의 합이 target 보다 작으면 left++</li>
  <li>이렇게 진행하면 결국 원하는 값을 찾게됨</li>
  <li>시간복잡도 O(n) / 공간복잡도 O(1)</li>
</ul>

<h1 id="소스">소스</h1>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 	 <span class="cm">/**
     * 1. 문제
     *  numbers 중 2개의 수를 더해 target 만족
     *
     * 제약조건
     * 공간복잡도 O(1)
     * numbers 중복허용
     * 2 &lt;= numbers.length &lt;= 3 * 104
     * -1000 &lt;= numbers[i] &lt;= 1000
     * numbers array asc
     * -1000 &lt;= target &lt;= 1000
     * 오직 1개의 solution 이 존재
     *
     *
     * 2. 풀이
     * 2.1 brute-force  (시간복잡도 O (n 제곱) )
     *  - for 2번 돌리면서 순회
     *  - target 보다 크면 stop
     *
     * 2.2 공간복잡도를 쓴다면
     *  Map 에 저장을 한다
     *  for loop 순회하면서 target - numbers[i] = map 에 있는지 체크
     *  이러면 시간복잡도 O(n)
     *
     * 2.3 two pointer
     *  양끝에서 시작
     *  양끝의 합이 target 보다 크면 right--
     *  양끝의 합이 target 보다 작으면 left++
     *
     *  시간복잡도 O(n) / 공간복잡도 O(1)
     */</span>

    <span class="k">fun</span> <span class="nf">twoSumBruteForce</span><span class="p">(</span><span class="n">numbers</span><span class="p">:</span> <span class="nc">IntArray</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="nc">IntArray</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="k">in</span> <span class="n">i</span> <span class="p">+</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">+</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">intArrayOf</span><span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="p">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nf">intArrayOf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fun</span> <span class="nf">twoSum</span><span class="p">(</span><span class="n">numbers</span><span class="p">:</span> <span class="nc">IntArray</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="nc">IntArray</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="py">left</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="kd">var</span> <span class="py">right</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span> <span class="p">-</span> <span class="mi">1</span>

        <span class="c1">// 무조건 답이 1개 있으니 true 로 해도 됨</span>
        <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">val</span> <span class="py">sum</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="p">+</span> <span class="n">numbers</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="p">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">intArrayOf</span><span class="p">(</span><span class="n">left</span> <span class="p">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span> <span class="p">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="p">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">left</span><span class="p">++</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="p">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">right--</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 이 경우는 없음</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nf">intArrayOf</span><span class="p">()</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name>leechoongyon</name></author><category term="leetcode" /><category term="leetcode" /><summary type="html"><![CDATA[소스코드]]></summary></entry><entry><title type="html">Leetcode167.RemoveDuplicatesFromSortedArrayII</title><link href="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/04/14/Leetcode167.TwoSumIIInputArrayIsSorted.html" rel="alternate" type="text/html" title="Leetcode167.RemoveDuplicatesFromSortedArrayII" /><published>2024-04-14T00:00:00+00:00</published><updated>2024-04-14T00:00:00+00:00</updated><id>https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/04/14/Leetcode167.TwoSumIIInputArrayIsSorted</id><content type="html" xml:base="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/04/14/Leetcode167.TwoSumIIInputArrayIsSorted.html"><![CDATA[<blockquote>
  <p><a href="https://github.com/leechoongyon/coding-test-kotlin/blob/main/src/main/kotlin/org/example/leetcode/Num167.kt">소스코드</a></p>
</blockquote>

<h1 id="문제">문제</h1>

<ul>
  <li><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/">167. Two Sum II - Input Array Is Sorted</a></li>
  <li>numbers int array 가 주어지며, numbers 중 2개의 숫자를 더해 target 을 만족</li>
</ul>

<h1 id="풀이-brute-force">풀이 (brute-force)</h1>

<ul>
  <li>
    <p>시간복잡도 O (n 제곱)</p>
  </li>
  <li>
    <p>for 2번 돌리면서 순회 target 보다 크면 stop</p>
  </li>
</ul>

<h1 id="풀이공간-사용">풀이(공간 사용)</h1>

<ul>
  <li>Map 에 저장을 한다</li>
  <li>for loop 순회하면서 target - numbers[i] = map 에 있는지 체크</li>
  <li>이러면 시간복잡도 O(n), 공간복잡도 또한 O(n)</li>
</ul>

<h1 id="풀이-two-pointer">풀이 (two Pointer)</h1>

<ul>
  <li>양끝에서 시작</li>
  <li>양끝의 합이 target 보다 크면 right–</li>
  <li>양끝의 합이 target 보다 작으면 left++</li>
  <li>이렇게 진행하면 결국 원하는 값을 찾게됨</li>
  <li>시간복잡도 O(n) / 공간복잡도 O(1)</li>
</ul>

<h1 id="소스">소스</h1>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 	 <span class="cm">/**
     * 1. 문제
     *  numbers 중 2개의 수를 더해 target 만족
     *
     * 제약조건
     * 공간복잡도 O(1)
     * numbers 중복허용
     * 2 &lt;= numbers.length &lt;= 3 * 104
     * -1000 &lt;= numbers[i] &lt;= 1000
     * numbers array asc
     * -1000 &lt;= target &lt;= 1000
     * 오직 1개의 solution 이 존재
     *
     *
     * 2. 풀이
     * 2.1 brute-force  (시간복잡도 O (n 제곱) )
     *  - for 2번 돌리면서 순회
     *  - target 보다 크면 stop
     *
     * 2.2 공간복잡도를 쓴다면
     *  Map 에 저장을 한다
     *  for loop 순회하면서 target - numbers[i] = map 에 있는지 체크
     *  이러면 시간복잡도 O(n)
     *
     * 2.3 two pointer
     *  양끝에서 시작
     *  양끝의 합이 target 보다 크면 right--
     *  양끝의 합이 target 보다 작으면 left++
     *
     *  시간복잡도 O(n) / 공간복잡도 O(1)
     */</span>

    <span class="k">fun</span> <span class="nf">twoSumBruteForce</span><span class="p">(</span><span class="n">numbers</span><span class="p">:</span> <span class="nc">IntArray</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="nc">IntArray</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="k">in</span> <span class="n">i</span> <span class="p">+</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">+</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">intArrayOf</span><span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="p">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nf">intArrayOf</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fun</span> <span class="nf">twoSum</span><span class="p">(</span><span class="n">numbers</span><span class="p">:</span> <span class="nc">IntArray</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="nc">IntArray</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="py">left</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="kd">var</span> <span class="py">right</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span> <span class="p">-</span> <span class="mi">1</span>

        <span class="c1">// 무조건 답이 1개 있으니 true 로 해도 됨</span>
        <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">val</span> <span class="py">sum</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="p">+</span> <span class="n">numbers</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="p">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">intArrayOf</span><span class="p">(</span><span class="n">left</span> <span class="p">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span> <span class="p">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="p">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">left</span><span class="p">++</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="p">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">right--</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 이 경우는 없음</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nf">intArrayOf</span><span class="p">()</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name>leechoongyon</name></author><category term="leetcode" /><category term="leetcode" /><summary type="html"><![CDATA[소스코드]]></summary></entry><entry><title type="html">Leetcode80.RemoveDuplicatesFromSortedArrayII</title><link href="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/04/13/Leetcode80.RemoveDuplicatesFromSortedArrayII.html" rel="alternate" type="text/html" title="Leetcode80.RemoveDuplicatesFromSortedArrayII" /><published>2024-04-13T00:00:00+00:00</published><updated>2024-04-13T00:00:00+00:00</updated><id>https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/04/13/Leetcode80.RemoveDuplicatesFromSortedArrayII</id><content type="html" xml:base="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/04/13/Leetcode80.RemoveDuplicatesFromSortedArrayII.html"><![CDATA[<blockquote>
  <p><a href="https://github.com/leechoongyon/coding-test-kotlin/blob/main/src/main/kotlin/org/example/leetcode/Num80.kt">소스코드</a></p>
</blockquote>

<h1 id="문제">문제</h1>

<ul>
  <li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/">80. RemoveDuplicatesFromSortedArrayII</a></li>
</ul>

<h1 id="풀이-brute-force">풀이 (brute-force)</h1>

<ul>
  <li>문제는 array 의 중복을 제거하는 것인데 최대 2개까지 허용</li>
  <li>중복 제거된 array 의 length 를 return 하고 중복 제거 후, nums 배열을 바꿔줘야함</li>
  <li>시간복잡도 O(n 제곱)</li>
  <li>순회하면서 앞뒤로 비교</li>
  <li>값이 같으면 2개까지 중복허용하고, 3개 이상 부터는 버림</li>
  <li>값이 틀리면 nums 를 수정</li>
  <li>요약 : nums 배열을 바꿔주면서 nums.length 를 구하는 것. 같으면 nums 배열 유지. 단, equalCount = 2 까지, 다르면 nums 채워넣어야 함</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/**
     * 1, 1, 1, 2, 2 ,3
     * 1 고정
     * 1, 1 eq = 2
     * 1, 1, 1 은 eq = 3 이니 skip -&gt; 1, 1
     * 1, 1, 1, 2 -&gt;  1, 1, 2
     * 1, 1, 1, 2, 2 -&gt; 1, 1, 2, 2
     * 1, 1, 1, 2, 2, 3 -&gt; 1, 1, 2, 2, 3
     */</span>
    <span class="k">fun</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="nc">IntArray</span><span class="p">):</span> <span class="nc">Int</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="py">k</span> <span class="p">=</span> <span class="mi">1</span>
        <span class="kd">var</span> <span class="py">equalCount</span> <span class="p">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="p">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">++]</span> <span class="p">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">equalCount</span> <span class="p">=</span> <span class="mi">1</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">equalCount</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">++]</span> <span class="p">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">equalCount</span><span class="p">++</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">k</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name>leechoongyon</name></author><category term="leetcode" /><category term="leetcode" /><summary type="html"><![CDATA[소스코드]]></summary></entry><entry><title type="html">k8s 정리</title><link href="https://leechoongyon.github.io//jekyll-theme-yat/k8s/2024/04/09/k8s-%EC%A0%95%EB%A6%AC.html" rel="alternate" type="text/html" title="k8s 정리" /><published>2024-04-09T00:00:00+00:00</published><updated>2024-04-09T00:00:00+00:00</updated><id>https://leechoongyon.github.io//jekyll-theme-yat/k8s/2024/04/09/k8s-%EC%A0%95%EB%A6%AC</id><content type="html" xml:base="https://leechoongyon.github.io//jekyll-theme-yat/k8s/2024/04/09/k8s-%EC%A0%95%EB%A6%AC.html"><![CDATA[<blockquote>
  <p>공부한 내용을 정리했습니다.</p>
</blockquote>

<h1 id="정리">정리</h1>

<ul>
  <li>docker-desktop 을 통해 k8s 를 구성하면 node 가 docker-desktop 으로 생성</li>
  <li>docker-desktop 에서 생성해도 외부에서 접근 가능하도록 하는법
    <ul>
      <li>만약 expose 한 것을 취소하고 싶으면 kubectl delete service <서비스 이름=""></서비스></li>
      <li>https://judekim.tistory.com/119 참고</li>
    </ul>
  </li>
  <li>deployment 로 생성하면 파드의 동작을 보장. pod 만 생성했을 경우 삭제하면 복구 안됨</li>
  <li>docker-desktop 을 통해 nodePort 를 열면 특정 노드 ip 로 접근이 가능한게 아니라 localhost 로 접근이 가능함</li>
  <li>외부로 pod 를 노출하는 방법
    <ul>
      <li>nodePort
        <ul>
          <li>파일로 만들어서 설정</li>
          <li>export 명령어를 통해 설정</li>
        </ul>
      </li>
      <li>인그레스
        <ul>
          <li>여러 deployment 로 외부 요청을 분배할 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="명령어-정리">명령어 정리</h1>
<ul>
  <li>pod 접속
    <ul>
      <li>kubectl exec -it <pod_name> -- bash</pod_name></li>
    </ul>
  </li>
  <li>deployment 조회 / 삭제
    <ul>
      <li>kubectl get deployments</li>
      <li>kubectl delete deployment <이름></이름></li>
    </ul>
  </li>
  <li>node 상세 조회
    <ul>
      <li>kubectl get nodes -o wide</li>
    </ul>
  </li>
  <li>replica 증가
    <ul>
      <li>kubectl scale deployment <deployment 이름=""> --replicas=3</deployment></li>
    </ul>
  </li>
  <li>default 네임스페이스가 아닌 다른 namespace 조회
    <ul>
      <li>kubectl get pods -&gt; default namespace 조회</li>
      <li>kubectl get pods -n ingress-nginx -&gt; ingress-nginx 네임스페이스 조회</li>
    </ul>
  </li>
</ul>]]></content><author><name>leechoongyon</name></author><category term="k8s" /><category term="k8s" /><summary type="html"><![CDATA[공부한 내용을 정리했습니다.]]></summary></entry><entry><title type="html">Leetcode713.SubarrayProductLessThanK</title><link href="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/04/02/Leetcode713.SubarrayProductLessThanK.html" rel="alternate" type="text/html" title="Leetcode713.SubarrayProductLessThanK" /><published>2024-04-02T00:00:00+00:00</published><updated>2024-04-02T00:00:00+00:00</updated><id>https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/04/02/Leetcode713.SubarrayProductLessThanK</id><content type="html" xml:base="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/04/02/Leetcode713.SubarrayProductLessThanK.html"><![CDATA[<blockquote>
  <p><a href="https://github.com/leechoongyon/coding-test-kotlin/blob/main/src/main/kotlin/org/example/leetcode/Num713.kt">소스코드</a></p>
</blockquote>

<h1 id="문제">문제</h1>

<ul>
  <li><a href="https://leetcode.com/problems/subarray-product-less-than-k/description/">713. SubarrayProductLessThanK</a></li>
</ul>

<h1 id="풀이-brute-force">풀이 (brute-force)</h1>

<ul>
  <li>시간복잡도 O(n 제곱)</li>
  <li>아래 문제 풀 때, 실수는 end 를 원위치 시키는 것</li>
  <li>연속적이고 부분배열을 구하는거면 Window 를 고려</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="cm">/**
     * 10  count 1
     * 10 * 5 -&gt; count 2
     * 10 * 5 * 2 &lt; 100 -&gt; 멈춤
     * 5 -&gt;    count 3
     * 5 * 2 -&gt; count 4
     * 5 * 2 * 6 -&gt; count 5
     * 2 -&gt; count 6
     * 2 * 6 -&gt; 7
     * 6 -&gt; 8
     *
     * brute-force
     * 시간복잡도 O(n 제곱)
     */</span>
    <span class="k">fun</span> <span class="nf">numSubarrayProductLessThanKBruteForce</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="nc">IntArray</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="nc">Int</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="py">left</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="kd">var</span> <span class="py">right</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="kd">var</span> <span class="py">count</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="kd">var</span> <span class="py">tmp</span> <span class="p">=</span> <span class="mi">1</span>
        <span class="kd">val</span> <span class="py">size</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span>

        <span class="c1">// 이건 윈도우 개념이 아님. 잘못 풀었음. right 와 start 를 움직이면서 부분집합의 개수를 구함</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="p">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tmp</span> <span class="p">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="p">&lt;</span> <span class="n">k</span> <span class="p">&amp;&amp;</span> <span class="n">right</span> <span class="p">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">count</span><span class="p">++</span>
                <span class="n">right</span><span class="p">++</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">left</span><span class="p">++</span>
                <span class="n">right</span> <span class="p">=</span> <span class="n">left</span>
                <span class="n">tmp</span> <span class="p">=</span> <span class="mi">1</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="p">==</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">left</span><span class="p">++</span>
                <span class="n">right</span> <span class="p">=</span> <span class="n">left</span>
                <span class="n">tmp</span> <span class="p">=</span> <span class="mi">1</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">count</span>
    <span class="p">}</span>
</code></pre></div></div>

<h1 id="풀이-window">풀이 (Window)</h1>

<ul>
  <li>window 크기는 부분배열의 크기</li>
  <li>right 를 움직이면서 window 부분배열의 곱이 k 이면 left 를 이동시킴</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">fun</span> <span class="nf">numSubarrayProductLessThanKUsingWindow</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="nc">IntArray</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="nc">Int</span> <span class="p">{</span>
        <span class="c1">// edge case</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="p">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="p">}</span>

        <span class="kd">var</span> <span class="py">count</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="kd">var</span> <span class="py">product</span> <span class="p">=</span> <span class="mi">1</span>

        <span class="kd">var</span> <span class="py">left</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="kd">var</span> <span class="py">right</span> <span class="p">=</span> <span class="mi">0</span>

        <span class="c1">// right 를 이동시키면서 window 를 늘려나가고, k 를 넘어서면 left 를 이동시킨다.</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="p">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">product</span> <span class="p">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>

            <span class="c1">// product 이 k 보다 크다면 left 를 증가시키면서 window 를 이동</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">product</span> <span class="p">&gt;=</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">product</span> <span class="p">/=</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">++]</span>
            <span class="p">}</span>

            <span class="c1">// right - left + 1 은 부분집합의 개수다. (= window size )</span>
            <span class="n">count</span> <span class="p">+=</span> <span class="n">right</span> <span class="p">-</span> <span class="n">left</span> <span class="p">+</span> <span class="mi">1</span>
            <span class="n">right</span><span class="p">++</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">count</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name>leechoongyon</name></author><category term="leetcode" /><category term="leetcode" /><summary type="html"><![CDATA[소스코드]]></summary></entry><entry><title type="html">Leetcode61.RotateList</title><link href="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/03/27/Leetcode61.RotateList.html" rel="alternate" type="text/html" title="Leetcode61.RotateList" /><published>2024-03-27T00:00:00+00:00</published><updated>2024-03-27T00:00:00+00:00</updated><id>https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/03/27/Leetcode61.RotateList</id><content type="html" xml:base="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/03/27/Leetcode61.RotateList.html"><![CDATA[<blockquote>
  <p><a href="https://github.com/leechoongyon/coding-test-kotlin/blob/main/src/main/kotlin/org/example/leetcode/Num61.kt">소스코드</a></p>
</blockquote>

<h1 id="문제">문제</h1>

<ul>
  <li><a href="https://leetcode.com/problems/rotate-list/description/">61. RotateList</a></li>
</ul>

<h1 id="풀이-brute-force">풀이 (brute-force)</h1>

<ul>
  <li>방향성은 single list -&gt; 순환 list 를 만든 뒤, 특정 지점에서 순환을 끊는 것이다.</li>
  <li>시간 복잡도 O(n)</li>
  <li>상세 설명은 주석</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">fun</span> <span class="nf">rotateRight</span><span class="p">(</span><span class="n">head</span><span class="p">:</span> <span class="nc">ListNode</span><span class="p">?,</span> <span class="n">k</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="nc">ListNode</span><span class="p">?</span> <span class="p">{</span>
        <span class="c1">// null 과 0 을 체크</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">k</span> <span class="p">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">head</span>
        <span class="p">}</span>

        <span class="kd">var</span> <span class="py">copy</span> <span class="p">=</span> <span class="n">head</span>
        <span class="kd">var</span> <span class="py">size</span> <span class="p">=</span> <span class="mi">1</span>
        <span class="kd">var</span> <span class="py">tail</span><span class="p">:</span> <span class="nc">ListNode</span><span class="p">?</span>

        <span class="c1">// 크기</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">copy</span><span class="o">?.</span><span class="n">next</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">copy</span> <span class="p">=</span> <span class="n">copy</span><span class="p">.</span><span class="n">next</span>
            <span class="n">size</span><span class="p">++</span>
        <span class="p">}</span>
        <span class="c1">// tail 용도는 순환구조를 만들기 위함</span>
        <span class="n">tail</span> <span class="p">=</span> <span class="n">copy</span>

        <span class="kd">val</span> <span class="py">rotate</span> <span class="p">=</span> <span class="n">k</span> <span class="p">%</span> <span class="n">size</span>
        <span class="c1">// 회전을 nodeSize 만큼 수행하면 원점</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rotate</span> <span class="p">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">head</span>
        <span class="p">}</span>


        <span class="c1">// 회전 후, 시작지점 찾기</span>
        <span class="n">copy</span> <span class="p">=</span> <span class="n">head</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">size</span> <span class="p">-</span> <span class="n">rotate</span> <span class="p">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">copy</span> <span class="p">=</span> <span class="n">copy</span><span class="o">?.</span><span class="n">next</span>
        <span class="p">}</span>

      	<span class="c1">// 이 부분이 어려움 순환 구조를 만든 뒤, 순환구조를 끊는 부분</span>
        <span class="c1">// [1,2,3] k = 2 라 가정</span>
        <span class="n">tail</span><span class="o">?.</span><span class="n">next</span> <span class="p">=</span> <span class="n">head</span> <span class="c1">// 순환   </span>
        <span class="kd">val</span> <span class="py">newHead</span> <span class="p">=</span> <span class="n">copy</span><span class="o">?.</span><span class="n">next</span>    <span class="c1">// copy.next 는 2 를 가리킴. newHead 는 2, 3</span>
        <span class="n">copy</span><span class="o">?.</span><span class="n">next</span> <span class="p">=</span>
            <span class="k">null</span>   <span class="c1">// copy 는 1번을 가리키고, copy.next 는 2번을 가리키고 있음. newHead 2 -&gt; 3 -&gt; 1 -&gt; copy.next = null 로 해서 순환을 끊는거임</span>

        <span class="k">return</span> <span class="n">newHead</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name>leechoongyon</name></author><category term="leetcode" /><category term="leetcode" /><summary type="html"><![CDATA[소스코드]]></summary></entry><entry><title type="html">Leetcode41.FirstMissingPositive</title><link href="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/03/26/Leetcode41.FirstMissingPositive.html" rel="alternate" type="text/html" title="Leetcode41.FirstMissingPositive" /><published>2024-03-26T00:00:00+00:00</published><updated>2024-03-26T00:00:00+00:00</updated><id>https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/03/26/Leetcode41.FirstMissingPositive</id><content type="html" xml:base="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/03/26/Leetcode41.FirstMissingPositive.html"><![CDATA[<blockquote>
  <p><a href="https://github.com/leechoongyon/coding-test-kotlin/blob/main/src/main/kotlin/org/example/leetcode/Num41.kt">소스코드</a></p>
</blockquote>

<h1 id="문제">문제</h1>

<ul>
  <li>[<a href="https://leetcode.com/problems/first-missing-positive/">41. First Missing Positive</a>]</li>
</ul>

<h1 id="풀이-brute-force">풀이 (brute-force)</h1>

<ul>
  <li>순회하면서 HashMap 에 데이터를 마킹한다.</li>
  <li>HashMap 을 처음부터 순회하면서 missing num 을 찾는다.</li>
  <li>시간복잡도, 공간복잡도 O(n)</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">fun</span> <span class="nf">firstMissingPositive</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="nc">IntArray</span><span class="p">):</span> <span class="nc">Int</span> <span class="p">{</span>
        <span class="kd">val</span> <span class="py">hashMap</span> <span class="p">=</span> <span class="nc">HashMap</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">,</span> <span class="nc">Boolean</span><span class="p">&gt;()</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">num</span> <span class="k">in</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">hashMap</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="p">=</span> <span class="k">true</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kd">var</span> <span class="py">missingNum</span> <span class="p">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">hashMap</span><span class="p">.</span><span class="nf">containsKey</span><span class="p">(</span><span class="n">missingNum</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">missingNum</span><span class="p">++</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">missingNum</span>
    <span class="p">}</span>
</code></pre></div></div>

<h1 id="풀이--공간복잡도-o1-">풀이 ( 공간복잡도 O(1) )</h1>

<ul>
  <li>상세 풀이 주석</li>
  <li>전체적인 방향은 기존 nums 를 재활용하는 것</li>
  <li>nums 는 1&lt;= nums.length &lt;= 10의 5승    -&gt; 이 말은 10의 5승을 넘어서는 값이 나올 수 없다는 것</li>
  <li>nums 에 1~10의 5승에 대한 값이 존재하면 0 표시, 범위 밖이라면 -1 표시</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="cm">/**
     * 제약 조건을 보면 1&lt;= nums.length &lt;= 10의 5승임
     * 숫자가 연속적으로 나와도 10의 5승 범위를 벗어나는 값이 나올수가 없음
     *
     * 전체 방향은 기존 nums 를 재활용하는 것이다.
     */</span>
    <span class="k">fun</span> <span class="nf">firstMissingPositive</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="nc">IntArray</span><span class="p">):</span> <span class="nc">Int</span> <span class="p">{</span>
        <span class="kd">val</span> <span class="py">numsSize</span> <span class="p">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span>
        <span class="c1">// 범위 이외의 값을 -1 처리</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="mi">1</span> <span class="p">||</span> <span class="n">numsSize</span> <span class="p">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="p">-</span><span class="mi">1</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 범위 안의 값이 존재한다면 nums 에 0 으로 표시한다.</span>
        <span class="c1">// 예를 들면, [3,4,5] 가 nums 라면 nums[3] = nums[4] = nums[5] = 0 이다.</span>
        <span class="c1">// 0 이라는 것은 값이 존재한다는 것</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">marking</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="p">}</span>

        <span class="c1">// 순회하면서 nums 가 0 이 아닌 것은 반환한다.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">i</span> <span class="p">+</span> <span class="mi">1</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// nums 가 전부 채워졌다는건 10의 5승 다음 숫자를 의미</span>
        <span class="k">return</span> <span class="n">numsSize</span> <span class="p">+</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="cm">/**
     * 순회한 num 이 nums 범위안에 있으면 nums[num-1] = 0 으로 표시
     * ex) num 3 이고, nums[3-1] = 0 이면 3 은 존재하는 숫자라는 의미
     * nums[0] = 0 이면 1은 존재하는 숫자
     */</span>
    <span class="k">fun</span> <span class="nf">marking</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="nc">IntArray</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">val</span> <span class="py">tmp</span> <span class="p">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">num</span> <span class="p">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">num</span> <span class="p">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
            <span class="nf">marking</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>  <span class="c1">// 중요. 기존에 존재하던 값은 위치를 찾아준다.</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name>leechoongyon</name></author><category term="leetcode" /><category term="leetcode" /><summary type="html"><![CDATA[소스코드]]></summary></entry><entry><title type="html">Leetcode 1669.MergeInBetweenLinkedLists</title><link href="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/03/21/Leetcode1669.MergeInBetweenLinkedLists.html" rel="alternate" type="text/html" title="Leetcode 1669.MergeInBetweenLinkedLists" /><published>2024-03-21T00:00:00+00:00</published><updated>2024-03-21T00:00:00+00:00</updated><id>https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/03/21/Leetcode1669.MergeInBetweenLinkedLists</id><content type="html" xml:base="https://leechoongyon.github.io//jekyll-theme-yat/leetcode/2024/03/21/Leetcode1669.MergeInBetweenLinkedLists.html"><![CDATA[<blockquote>
  <p><a href="https://github.com/leechoongyon/coding-test-kotlin/blob/main/src/main/kotlin/org/example/leetcode/Num1669.kt">소스코드</a></p>
</blockquote>

<h1 id="문제">문제</h1>

<ul>
  <li><a href="https://leetcode.com/problems/merge-in-between-linked-lists/description/">1669.MergeInBetweenLinkedLists</a></li>
</ul>

<h1 id="풀이-brute-force">풀이 (brute-force)</h1>

<ul>
  <li>상세 풀이 주석</li>
  <li>시간 복잡도 O(n)</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
     * 1. 문제
     *  - listNode1, 2 가 주어짐.
     *  - listNode1 의 a,b 번째를 삭제한다.
     *  - 그 사이에 listNode2 를 채운다.
     *
     * 제약 조건
     * 3 &lt;= list1.length &lt;= 104
     * 1 &lt;= a &lt;= b &lt; list1.length - 1
     * 1 &lt;= list2.length &lt;= 104
     *
     * 2. 풀이 (brute-force)
     *  - list1 을 순회하면서 ListNode result 에 추가한다.
     *  - list1 a 를 만나면 list2 를 result 에 추가한다.
     *  - list1 b 까지 순회하고, 나머지를 result 에 추가한다.
     *  - 시간복잡도 O(n)
     *
     */</span>
    <span class="k">fun</span> <span class="nf">mergeInBetween</span><span class="p">(</span>
        <span class="n">list1</span><span class="p">:</span> <span class="nc">ListNode</span><span class="p">,</span>
        <span class="n">a</span><span class="p">:</span> <span class="nc">Int</span><span class="p">,</span>
        <span class="n">b</span><span class="p">:</span> <span class="nc">Int</span><span class="p">,</span>
        <span class="n">list2</span><span class="p">:</span> <span class="nc">ListNode</span>
    <span class="p">):</span> <span class="nc">ListNode</span> <span class="p">{</span>
        <span class="c1">// a 는 1이상이니 list1[0] 인덱스를 처음에 넣어준다.</span>
        <span class="kd">val</span> <span class="py">result</span> <span class="p">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="n">list1</span><span class="p">.</span><span class="n">`val`</span><span class="p">)</span>
        <span class="c1">// tail 은 항상 result 의 마지막 next 를 가리켜야 함. tail 을 사용하는 이유는 매번 끝까지 조회하는 것은 비용이 크기 때문</span>
        <span class="kd">var</span> <span class="py">tail</span> <span class="p">=</span> <span class="n">result</span>
        <span class="c1">// idx 는 listnode1 의 index 를 의미. a 는 1이상이니 idx 는 1부터 시작</span>
        <span class="kd">var</span> <span class="py">idx</span> <span class="p">=</span> <span class="mi">1</span>

        <span class="c1">// list1 의 current listnode</span>
        <span class="kd">var</span> <span class="py">current</span> <span class="p">=</span> <span class="n">list1</span>

        <span class="c1">// list1 을 순회하면서 list2 를 넣는다.</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">next</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// list2 를 추가할 조건</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">&lt;=</span> <span class="n">idx</span> <span class="p">&amp;&amp;</span> <span class="n">idx</span> <span class="p">&lt;=</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 마지막을 list2 에 연결시켜줌</span>
                <span class="n">tail</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="n">list2</span>
                <span class="c1">// 마지막은 list2 의 마지막을 가리켜야 함</span>
                <span class="n">tail</span> <span class="p">=</span> <span class="nf">getLastListNode</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span>
                <span class="c1">// a 부터 b 까지 제거할 예정이니 b+1 까지 current 를 순회</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">idx</span> <span class="p">&lt;=</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">current</span> <span class="p">=</span> <span class="n">current</span><span class="p">.</span><span class="n">next</span><span class="o">!!</span>
                    <span class="n">idx</span><span class="p">++</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="c1">// tail.next -&gt; result 마지막 next 가리킴</span>
            <span class="n">tail</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="nc">ListNode</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">next</span><span class="o">!!</span><span class="p">.</span><span class="n">`val`</span><span class="p">)</span>
            <span class="c1">// tail.next 는 result 마지막의 next 의미. 그것을 다시 tail 붙여서 result 마지막 next 를 가리킴</span>
            <span class="n">tail</span> <span class="p">=</span> <span class="n">tail</span><span class="p">.</span><span class="n">next</span><span class="o">!!</span>

            <span class="n">current</span> <span class="p">=</span> <span class="n">current</span><span class="p">.</span><span class="n">next</span><span class="o">!!</span>
            <span class="n">idx</span><span class="p">++</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="p">}</span>

    <span class="c1">// listNode 마지막 return</span>
    <span class="k">fun</span> <span class="nf">getLastListNode</span><span class="p">(</span><span class="n">listNode</span><span class="p">:</span> <span class="nc">ListNode</span><span class="p">):</span> <span class="nc">ListNode</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="py">tmp</span> <span class="p">=</span> <span class="n">listNode</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">next</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tmp</span> <span class="p">=</span> <span class="n">tmp</span><span class="p">.</span><span class="n">next</span><span class="o">!!</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">tmp</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name>leechoongyon</name></author><category term="leetcode" /><category term="leetcode" /><summary type="html"><![CDATA[소스코드]]></summary></entry><entry><title type="html">주변 친구 시스템 디자인</title><link href="https://leechoongyon.github.io//jekyll-theme-yat/systemdesign/2024/03/20/%EC%A3%BC%EB%B3%80%EC%B9%9C%EA%B5%AC-%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%94%94%EC%9E%90%EC%9D%B8.html" rel="alternate" type="text/html" title="주변 친구 시스템 디자인" /><published>2024-03-20T00:00:00+00:00</published><updated>2024-03-20T00:00:00+00:00</updated><id>https://leechoongyon.github.io//jekyll-theme-yat/systemdesign/2024/03/20/%EC%A3%BC%EB%B3%80%EC%B9%9C%EA%B5%AC%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%94%94%EC%9E%90%EC%9D%B8</id><content type="html" xml:base="https://leechoongyon.github.io//jekyll-theme-yat/systemdesign/2024/03/20/%EC%A3%BC%EB%B3%80%EC%B9%9C%EA%B5%AC-%EC%8B%9C%EC%8A%A4%ED%85%9C%EB%94%94%EC%9E%90%EC%9D%B8.html"><![CDATA[<blockquote>
  <p>공부한 내용을 정리했습니다.</p>
</blockquote>

<h1 id="문제">문제</h1>

<ul>
  <li>주변 친구의 기능을 가진 Application 설계</li>
  <li>사용자는 주변 친구의 목록을 받을 수 있음</li>
</ul>

<h1 id="요구사항">요구사항</h1>

<ul>
  <li>사용자는 모바일에서 주변 친구 확인 가능 (거리, 시각 표시)</li>
  <li>low latency - 주변 친구 위치 변화 반영이 너무 오래 걸리면 안됨</li>
  <li>일정 시간 지난 후, 사용하지 않으면 비활성화</li>
</ul>

<h1 id="설계">설계</h1>

<h3 id="주변-친구-목록">주변 친구 목록</h3>

<ul>
  <li>사용자의 위치를 매번 체크해야하는데 이것을 공통 백엔드 서버에서 받으면 처리가 힘들 수 있음</li>
  <li>웹소켓 서버를 세팅한 후, 사용자 별로 웹소켓에 연결시킴 -&gt; 사용자 위치가 변경될 때, 웹소켓을 통해 Redis pub/sub 에 메시지를 전달 -&gt; 특정 subscribe 에 연결된 다른 친구들의 웹소켓서버들은 그것을 받아 거리를 다시 계산
    <ul>
      <li>여기서 Redis 를 선택한 이유는 비용이 적은 채널을 생성할 수 있기 때문</li>
    </ul>
  </li>
  <li>시나리오
    <ul>
      <li>클라이언트 위치 정보 웹소켓으로 전달 -&gt; LB -&gt; API 서버, 웹소켓 서버
        <ul>
          <li>LB -&gt; API -&gt; RDB  (위치 정보 등)</li>
          <li>LB -&gt; 웹소켓 -&gt; Redis pub/sub -&gt; 친구 웹소켓에서 데이터를 가져가 거리, 시간 계산 -&gt; 친구에게 전달</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="사용자-비활성화">사용자 비활성화</h3>

<ul>
  <li>레디스에 위치 정보 캐시를 TTL 에 추가</li>
  <li>TTL 이 지났다면 사용자 비활성화 처리</li>
</ul>

<h1 id="시스템-확장">시스템 확장</h1>

<h3 id="웹소켓">웹소켓</h3>

<ul>
  <li>사용자 규모 늘어나면 웹소켓 서버를 늘리면 됨</li>
  <li>단, 기존 서버를 삭제할 때는 기존 연결이 종료된 후에 제거 필요
    <ul>
      <li>신규 사용자가 삭제 대상인 웹소켓으로 연결이 될 수 있기 때문</li>
      <li>제거 예정인 기존 서버에 접근 못하도록 조치 필요</li>
    </ul>
  </li>
</ul>

<h3 id="redis">Redis</h3>

<h5 id="메모리-관점">메모리 관점</h5>

<ul>
  <li>사용자 규모 늘어나면 위치 정보가 늘어날테고, 위치 갱신도 자주 일어날 것이다</li>
  <li>Redis 를 클러스터로 구성하거나 특정 값을 기준으로 샤딩 처리를 하는 방안을 고민해볼 수 있음</li>
</ul>

<h1 id="기타">기타</h1>

<h3 id="위치-정보-이력을-저장">위치 정보 이력을 저장</h3>

<ul>
  <li>쓰기가 많이 일어날테니 쓰기에 적합한 데이터베이스 선택</li>
  <li>데이터가 늘어날수록 파티셔닝 or 샤딩 필요</li>
</ul>]]></content><author><name>leechoongyon</name></author><category term="systemdesign" /><category term="systemdesign" /><summary type="html"><![CDATA[공부한 내용을 정리했습니다.]]></summary></entry></feed>